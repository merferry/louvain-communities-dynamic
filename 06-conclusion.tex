In conclusion, in this report we presented our Parallel Dynamic Frontier (DF) Louvain algorithm, which given a batch update of edge deletions or insertions, incrementally identifies and processes an approximate set of affected vertices in the graph with minimal overhead. In addition, we use a novel approach of incrementally updating weighted-degrees of vertices and total edge weights of communities, by using them as auxiliary information to DF Louvain. We also present our parallel implementations of Naive-dynamic (ND) \cite{com-aynaud10} and Delta-screening (DS) Louvain \cite{com-zarayeneh21}. On a server with a 64-core AMD EPYC-7742 processor, our experiments show that DF Louvain obtains speedups of $179\times$, $7.2\times$, and $5.3\times$ on real-world dynamic graphs, compared to Static, ND, and DS Louvain, respectively, and is $183\times$, $13.8\times$, and $8.7\times$ faster, respectively, on large graphs with random batch updates. Note that our static implementation of the Louvain algorithm, GVE-Louvain, here referred to Static Louvain, is itself $50\times$, $22\times$, $20\times$, and $5.8\times$ faster than Vite, Grappolo, NetworKit Louvain, and cuGraph Louvain (running on NVIDIA A100 GPU) \cite{sahu2023gvelouvain}. The performance of DF Louvain can be attributed to incremental marking, and marking of fewer vertices. Furthermore, DF Louvain improves performance at a rate of $1.6\times$ for every doubling of threads. DF Louvain is based on one of the fastest implementations of Static Louvain \cite{sahu2023gvelouvain} and thus offers state-of-the-art performance. However, we observe DF Louvain to obtain lower modularity score on the \textit{sx-superuser} real-world dynamic graph. We thus recommend the reader to use DF Louvain for updating community memberships on dynamic graphs, but switch to DS Louvain if lower modularity is observed.
