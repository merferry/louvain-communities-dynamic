Identifying hidden communities within networks is a crucial graph analytics problem that arises in various domains such as drug discovery, disease prediction, protein annotation, topic discovery, inferring land use, and criminal identification. The main objective is to identify groups of vertices that exhibit dense internal connections but sparse connections with the rest of the graph \cite{com-gregory10}. However, this problem is NP-hard, and there is a lack of apriori knowledge on the number and size distribution of communities \cite{com-blondel08}.

To solve this issue, researches have come up with a number of heuristics for finding communities. These include label propagation \cite{com-raghavan07, com-gregory10}, random walk \cite{com-rosvall08}, diffusion \cite{com-kloster14}, spin dynamics \cite{com-reichardt06}, fitness metric optimization \cite{com-newman06, com-fortunato10}, statistical inference \cite{com-come15, com-newman16}, core clustering \cite{com-ruan15}, simulated annealing \cite{com-guimera05, com-reichardt06}, clique percolation \cite{com-derenyi05, com-gupta22}, information theory (infomap) \cite{infomap-rosvall09, com-rita20}, and  biological evolution (genetics) \cite{com-ghoshal19, com-lu20} are studied over the decades for this problem. To evaluate the success of these methods, metrics such as the modularity score \cite{com-newman06, com-blondel08}, Normalized Mutual Information index (NMI) \cite{com-jain17, com-chopade17}, and Jaccard Index \cite{com-jain17} are often employed.

The \textit{Louvain} algorithm, based on modularity optimization, employs a greedy strategy to hierarchically merge graph vertices and extract communities \cite{com-blondel08}. It has a time complexity of $O(KM)$ (where $M$ represents the number of edges in the graph, $K$ represents the total number of iterations performed across all passes), and it efficiently identifies communities with resulting high modularity. As a result, the \textit{Louvain} method is widely favored among researchers \cite{com-lancichinetti09}.

Algorithmic improvements to the original algorithm have been proposed, which include early pruning of non-promising candidates (leaf vertices) \cite{com-ryu16, com-halappanavar17, com-zhang21, com-you22}, attempting local move only on likely vertices \cite{com-ryu16, com-ozaki16, com-zhang21, com-shi21}, ordering of vertices based on node importance \cite{com-aldabobi22}, moving nodes to a random neighbor community \cite{com-traag15}, threshold scaling \cite{com-lu15, com-naim17, com-halappanavar17}, threshold cycling \cite{com-ghosh18}, subnetwork refinement \cite{com-waltman13, com-traag19}, multilevel refinement \cite{com-rotta11, com-gach14, com-shi21}, and early termination \cite{com-ghosh18},

To parallelize the algorithm on multicore CPUs, GPUs \cite{com-cheong13}, hybrid CPU-GPUs \cite{com-bhowmik19}, multi GPUs \cite{com-cheong13, com-gawande22, com-bhowmick22}, and distributed systems \cite{com-bhowmick22}, a number of strategies have been attempted. These include parallelizing the costly first iteration \cite{com-wickramaarachchi14}, performing iterations asynchronously \cite{com-que15, com-shi21}, ordering vertices via graph coloring \cite{com-halappanavar17}, using vector based hashtables \cite{com-halappanavar17}, using adaptive parallel thread assignment \cite{com-fazlali17, com-naim17, com-mohammadi20}, using sort-reduce instead of hashing \cite{com-cheong13}, using simple partitions based of vertex ids \cite{com-cheong13, com-ghosh18}, and identifying and moving ghost/doubtful vertices \cite{com-zeng15, com-que15, com-bhowmik19, com-bhowmick22}.

The \textit{Label Propagation Algorithm (LPA)} is a method used for identifying communities or groups within a network by initializing each vertex with a unique label and diffusing these labels across the graph. It is faster and more scalable than the Louvain algorithm, as it does not require repeated optimization steps and is easy to parallelize \cite{com-newman04, com-raghavan07}.

Improvements upon the LPA include using a stable (non-random) mechanism of label choosing in the case of multiple best labels \cite{com-xing14}, addressing the issue of monster communities \cite{com-berahmand18, com-sattari18}, identifying central nodes and combining communities for improved modularity \cite{com-you20}, and using frontiers with alternating push-pull to reduce the number of edges visited and improve solution quality \cite{com-liu20}. A GPU-accelerated parallel implementation of the original LPA is available that is able to deal with large-scale datasets that do not fit into GPU memory \cite{com-kozawa17}.

A growing number of research efforts have focused on detecting communities in dynamic networks. The simplest approach is to use the community membership of vertices from the previous snapshot of the graph \cite{com-aynaud10, com-chong13, com-shang14, com-zhuang19} (which we call \textit{Naive-dynamic}). Alternatively, more advanced techniques have been employed to minimize computation by identifying a smaller subset of the graph that is affected by changes, such as moving only changed vertices \cite{com-aktunc15, com-yin16}, recomputing vertices close to an updated edge (below a given threshold distance) \cite{com-held16}, disbanding affected communities to lower-level network \cite{com-cordeiro16}, or using a dynamic modularity metric to compute community membership of vertices from scratch \cite{com-meng16}. \textit{Delta-Screening} (or \textit{$\Delta$-screening}) is a recently proposed technique that finds a subset of vertices impacted by changes in a graph using delta-modularity \cite{com-zarayeneh21}.

Significant research effort has also been dedicated to the development of dynamic label-propagation methods, due to their simplicity, efficiency, and scalability. In addition to the \textit{Naive-dynamic} approach, a number of advanced techniques been proposed. These include using the MapReduce model to efficiently adjust the communities of certain vertices based on previous intervals \cite{com-li17}, and using a stabilized label propagation process based on the static LabelRank algorithm \cite{com-xie13}. Adaptive Label Propagation Algorithm (ALPA) is another dynamic approach, which first performs a warm-up LPA on a subset of the network determined by edge deletions and insertions, followed by Local Label Propagation (LLP) which expands as a frontier of nodes that change labels and removes nodes that do not change labels \cite{com-han17}.
