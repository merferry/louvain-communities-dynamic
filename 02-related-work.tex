Identifying hidden communities within networks is a crucial graph analytics problem that arises in various domains such as drug discovery, disease prediction, protein annotation, topic discovery, inferring land use, and criminal identification. The main objective is to identify groups of vertices that exhibit dense internal connections but sparse connections with the rest of the graph \cite{com-gregory10}. However, this problem is NP-hard, and there is a lack of apriori knowledge on the number and size distribution of communities \cite{com-blondel08}.

To solve this issue, researches have come up with a number of heuristics for finding communities. These include label propagation \cite{com-raghavan07, com-gregory10}, random walk \cite{com-rosvall08}, diffusion \cite{com-kloster14}, spin dynamics \cite{com-reichardt06}, fitness metric optimization \cite{com-newman06, com-fortunato10}, statistical inference \cite{com-come15, com-newman16}, core clustering \cite{com-ruan15}, simulated annealing \cite{com-guimera05, com-reichardt06}, clique percolation \cite{com-derenyi05, com-gupta22}, information theory (infomap) \cite{infomap-rosvall09, com-rita20}, and  biological evolution (genetics) \cite{com-ghoshal19, com-lu20} are studied over the decades for this problem. To evaluate the success of these methods, metrics such as the modularity score \cite{com-newman06, com-blondel08}, Normalized Mutual Information index (NMI) \cite{com-jain17, com-chopade17}, and Jaccard Index \cite{com-jain17} are often employed.
\ignore{For many years, scholars have been searching for ways to uncover the hidden communities within networks. They have employed a variety of methods, including but not limited to label propagation \cite{com-raghavan07, com-gregory10, com-xie11}, random walk \cite{com-rosvall08}, diffusion \cite{com-kloster14}, spin dynamics \cite{com-reichardt06}, fitness metric optimization \cite{com-newman06, com-fortunato10}, statistical inference \cite{com-come15, com-newman16}, core clustering \cite{com-ruan15}, simulated annealing \cite{com-guimera05, com-reichardt06}, clique percolation \cite{com-derenyi05, com-maity14, com-gupta22}, information theory (infomap) \cite{com-zeng19, com-zeng18, com-faysal19, infomap-rosvall09, com-rita20}, and even biological evolution (genetics) \cite{com-taufan20, com-ghoshal19, com-lu20}. To evaluate the success of these methods, metrics such as the modularity score \cite{com-newman06, com-blondel08, com-ghoshal19}, Normalized Mutual Information index (NMI) \cite{com-jain17, com-chopade17}, and Jaccard Index \cite{com-jain17} are often employed.}

The \textit{Louvain} algorithm, based on modularity optimization, employs a greedy strategy to hierarchically merge graph vertices and extract communities \cite{com-blondel08}. It has a time complexity of $O(KM)$ (where $M$ represents the number of edges in the graph, $K$ represents the total number of iterations performed across all passes), and it efficiently identifies communities with resulting high modularity. As a result, the \textit{Louvain} method is widely favored among researchers \cite{com-lancichinetti09}.
\ignore{The \textit{Louvain} method is a greedy, modularity-based optimization algorithm, that hierarchically agglomerates vertices in a graph to obtain communities \cite{com-blondel08}. Due to its ability to find communities of high modularity with an average time complexity of $\Theta (n \log n)$ ($n$ being the total number of vertices in the graph), it is one of the most popular approaches \cite{com-lancichinetti09}.}

Algorithmic improvements to the original algorithm have been proposed, which include early pruning of non-promising candidates (leaf vertices) \cite{com-ryu16, com-halappanavar17, com-zhang21, com-you22}, attempting local move only on likely vertices \cite{com-ryu16, com-ozaki16, com-zhang21, com-shi21}, ordering of vertices based on node importance \cite{com-aldabobi22}, moving nodes to a random neighbor community \cite{com-traag15}, threshold scaling \cite{com-lu15, com-naim17, com-halappanavar17}, threshold cycling \cite{com-ghosh18}, subnetwork refinement \cite{com-waltman13, com-traag19}, multilevel refinement \cite{com-rotta11, com-gach14, com-shi21}, and early termination \cite{com-ghosh18},

To parallelize the algorithm on multicore CPUs, GPUs \cite{com-cheong13}, hybrid CPU-GPUs \cite{com-bhowmik19}, multi GPUs \cite{com-cheong13, com-gawande22, com-bhowmick22}, and distributed systems \cite{com-bhowmick22}, a number of strategies have been attempted. These include parallelizing the costly first iteration \cite{com-wickramaarachchi14}, performing iterations asynchronously \cite{com-que15, com-shi21}, ordering vertices via graph coloring \cite{com-halappanavar17}, using vector based hashtables \cite{com-halappanavar17}, using adaptive parallel thread assignment \cite{com-fazlali17, com-naim17, com-mohammadi20}, using sort-reduce instead of hashing \cite{com-cheong13}, using simple partitions based of vertex ids \cite{com-cheong13, com-ghosh18}, and identifying and moving ghost/doubtful vertices \cite{com-zeng15, com-que15, com-bhowmik19, com-bhowmick22}.






\paragraph{Louvain algorithm \cite{com-blondel08}}

The Louvain algorithm is a popular algorithm to efficiently identify communities with a high modularity. As a result, it is widely favored among researchers \cite{com-lancichinetti09}. Algorithmic improvements to the \Lou{} method include early pruning of non-promising candidates \cite{com-halappanavar17}, threshold scaling \cite{com-naim17, com-halappanavar17}, threshold cycling \cite{com-ghosh18}, and early termination \cite{com-ghosh18}.

A variety  of techniques have been studied to parallelize the \Lou{} algorithm on multicore CPUs, GPUs \cite{com-cheong13}, hybrid CPU-GPUs, multi GPUs \cite{com-cheong13, com-bhowmick22}, and distributed systems \cite{com-bhowmick22}, These include parallelizing the costly first iteration \cite{com-wickramaarachchi14}, ordering vertices via graph coloring \cite{com-halappanavar17}, using vector-based hashtables for data caching \cite{com-halappanavar17}, using adaptive parallel thread assignment \cite{com-naim17}, using sort-reduce instead of hashing \cite{com-cheong13}, using simple partitions based on vertex ids \cite{com-cheong13, com-ghosh18}, and identifying and moving ghost/doubtful vertices \cite{com-bhowmick22}.

A growing number of research efforts have focused on detecting communities in \textit{dynamic networks}. A core idea among most approaches is to use the community membership of each vertex from the previous snapshot of the graph, instead of initializing each vertex into singleton communities \cite{com-aynaud10, com-chong13, com-cordeiro16, com-zarayeneh21}. Aynaud et al. \cite{com-aynaud10} simply run the Louvain algorithm after assigning the community membership of each vertex as its previous community membership. Chong et al. \cite{com-chong13} reset the community membership of vertices linked to an updated edge, in addition to the steps performed by Aynaud et al., and process all vertices with the Louvain algorithm.
\ignore{A growing number of research efforts have focused on detecting communities in dynamic networks. The simplest approach is to use the community membership of vertices from the previous snapshot of the graph \cite{com-aynaud10, com-chong13, com-shang14, com-zhuang19} (which we call \textit{Naive-dynamic}). Alternatively, more advanced techniques have been employed to minimize computation by identifying a smaller subset of the graph that is affected by changes, such as moving only changed vertices \cite{com-aktunc15, com-yin16}, recomputing vertices close to an updated edge (below a given threshold distance) \cite{com-held16}, disbanding affected communities to lower-level network \cite{com-cordeiro16}, or using a dynamic modularity metric to compute community membership of vertices from scratch \cite{com-meng16}. \textit{Delta-Screening} (or \textit{$\Delta$-screening}) is a recently proposed technique that finds a subset of vertices impacted by changes in a graph using delta-modularity \cite{com-zarayeneh21}.}
\ignore{A growing number of research efforts have focused on detecting communities in dynamic networks. The simplest approach is to use the community 
membership of vertices from the previous snapshot of the graph \cite{com-aynaud10, com-chong13, com-shang14, com-zhuang19} (which we call \textit{Naive-dynamic}). Alternatively, more advanced techniques have been employed to minimize computation by identifying a smaller subset of the graph that is affected by changes, such as moving only changed vertices \cite{com-aktunc15, com-yin16}, recomputing vertices close to an updated edge (below a given threshold distance) \cite{com-held16}, disbanding affected communities to lower-level network \cite{com-cordeiro16}, or using a dynamic modularity metric to compute community membership of vertices from scratch \cite{com-meng16}. \textit{Delta-Screening} (or \textit{$\Delta$-screening}) is a recently proposed technique that finds a subset of vertices impacted by changes in a graph using delta-modularity \cite{com-zarayeneh21}.}
\ignore{A growing number of research efforts have focused on detecting communities in dynamic networks. The simplest approach is to process starting with the community membership of vertices from the previous snapshot of the graph \cite{com-aynaud10} (which we call \textit{Naive-dynamic}). More advanced techniques for \textit{Louvain} include moving only changed vertices \cite{com-aktunc15}, recomputing vertices close to an updated edge \cite{com-held16}, disbanding affected communities to lower-level network \cite{com-cordeiro16}, or using a dynamic modularity metric \cite{com-meng16}. \textit{Delta-Screening} (or \textit{$\Delta$-screening}) is a recently proposed technique that finds a subset of vertices impacted by changes in a graph \cite{com-zarayeneh21}.}
\ignore{A growing number of research efforts have focused on detecting communities in dynamic networks. The simplest approach is to use the community membership of vertices from the previous snapshot of the graph \cite{com-aynaud10, com-chong13, com-shang14, com-zhuang19} (which we call \textit{Naive-dynamic}). Alternatively, more advanced techniques have been employed to minimize computation by identifying a smaller subset of the graph that is affected by changes, such as moving only changed vertices \cite{com-aktunc15, com-yin16}, recomputing vertices close to an updated edge (below a given threshold distance) \cite{com-held16}, disbanding affected communities to lower-level network \cite{com-cordeiro16}, or using a dynamic modularity metric to compute community membership of vertices from scratch \cite{com-meng16}. \textit{Delta-Screening} (or \textit{$\Delta$-screening}) is a recently proposed technique that finds a subset of vertices impacted by changes in a graph using delta-modularity \cite{com-zarayeneh21}.}

Meng et al. \cite{com-meng16} present a dynamic Louvain algorithm with an objective of obtaining temporally smoothed community structures as the graphs evolve over time. To avoid dramatic changes in community structure, they use an approximate version of delta-modularity optimization. This approximate formulation relies on both graphs in the previous and the current snapshot with a user-defined ratio. Their algorithm demonstrates improvement over Dynamic Spectral Clustering (DSC) and Multi-Step Community Detection (MSCD) in terms of runtime. In terms of quality of communities obtained (using modularity score), their algorithm outperforms DSC, and is on par with MSCD.
\ignore{Meng et al. \cite{com-meng16} propose a dynamic algorithm for tracking evolving community structures in temporal graphs. They use an approximate delta-modularity optimization, combining information from current and previous graph snapshots to ensure smooth transitions. Their algorithm is faster than Dynamic Spectral Clustering (DSC) and Multi-Step Community Detection (MSCD) and performs competitively in terms of community modularity. Cordeiro et al. \cite{com-cordeiro16} also introduce a dynamic algorithm for community tracking, focusing on local modularity optimization for communities affected by edits. Their algorithm outperforms several alternatives in runtime and achieves higher modularity scores.}

Cordeiro et al. \cite{com-cordeiro16} propose a dynamic algorithm with a similar objective, i.e., tracking communities over time. Their algorithm performs a local modularity optimization that maximizes the modularity gain function only for those communities where the editing of nodes and edges was performed by disbanding such communities to a lower-level network, keeping the rest of the network unchanged. They confirm supremacy of their algorithm over LabelRank, LabelRankT, Speakerâ€“Listener Label Propagation (SLPA), and Adaptive Finding Overlapping Community Structure (AFOCS) in terms of runtime --- and over LabelRank, LabelRankT and AFOCS in terms of modularity score.

Zarayeneh et al. \cite{com-zarayeneh21} put forward a technique called Delta-screening for updating communities in a dynamic graph. This technique examines edge deletions and insertions to the original graph, and identifies a subset of vertices that are likely to be impacted by the change using the modularity objective. Subsequently, only the identified subsets are processed for community state updates --- using two modularity optimization based community detection algorithms, Louvain and Smart Local-Moving (SLM). Their results demonstrate performance improvement over the Static Louvain algorithm, and a dynamic baseline version of Louvain algorithm \cite{com-aynaud10}. They also compare the performance of their algorithm against two other state-of-the-art methods DynaMo and Batch, and observe improvement over the methods both in terms of runtime and modularity.

While \Lou{} obtains high-modularity communities, we find it to be $2.3 - 14\times$ slower than \LPA{} (which obtains communities of lower modularity by $3.0 - 30\%$). We have experimented with COPRA \cite{com-gregory10}, SLPA \cite{com-xie11}, and LabelRank \cite{com-xie13}, but found LPA \cite{com-raghavan07} to be the most performant, while yielding communities of equivalent modularity. LPA is faster than the Louvain algorithm, as it does not require repeated optimization steps and is easier to parallelize. Improvements upon the \LPA{} include using stable max-label choosing \cite{com-xing14}, identifying central nodes and combining communities \cite{com-you20}, and using frontiers with alternating push-pull to reduce edges visited and improve solution modularity \cite{com-liu20}. For \LPA{}, a stabilized process based on LabelRank algorithm has been proposed \cite{com-xie13}. Adaptive Label Propagation Algorithm (ALPA) is another dynamic approach, which first performs a warm-up \LPA{} on a subset of the network, followed by Local Label Propagation (LLP) which expands as a frontier of nodes change labels \cite{com-han17}.




%% CRITICAL REVIEW

Existing works on \textit{Dynamic Louvain} algorithm, ,the ones proposed by Aynaud et al. \cite{com-aynaud10} and Chong et al. \cite{com-chong13} are essentially Naive-dynamic algorithms, as they end up processing all vertices in the graph (albeit for a fewer number of iterations). However, finding a subset of vertices that need to be processed can help minimize computation time, which is critical for dynamic graph algorithms.

The dynamic algorithm put forth by Meng et al. \cite{com-meng16} provides temporal smoothing of community memberships. But, it does not improve upon the performance of Static Louvain algorithm. Thus it fails to satisfy one of the main objectives of a dynamic community detection algorithm, i.e., to outperform the static algorithm such that an updated community structure can be quickly obtained. Further, it obtains lower modularity scores than the Static Louvain algorithm. Meng et al. state this to be due to their algorithm trading modularity maximization for temporal smoothing of community memberships. The dynamic algorithm introduced by Cordeiro et al. \cite{com-cordeiro16} obtains similar modularity scores as the Static Louvain algorithm, but is generally slower even for small batch updates.
\ignore{Let us now move on to dynamic Louvain algorithms. The ones proposed by Aynaud et al. \cite{com-aynaud10} and Chong et al. \cite{com-chong13} are essentially Naive-dynamic algorithms, as they end up processing all vertices in the graph (albeit for a fewer number of iterations).\ignore{However, finding a subset of vertices that need to be processed can help minimize computation time, which is critical for dynamic graph algorithms.} Often, this is unwarranted since not every vertex would need to change its community on the deletion/insertion of a few edges. The dynamic algorithms put forth by Meng et al. \cite{com-meng16} and Cordeiro et al. \cite{com-cordeiro16} fail to outperform the static algorithms even for modest sized batch updates. The \textit{$\Delta$-screening} technique laid out by Zarayeneh et al. \cite{com-zarayeneh21} identifies a subset of vertices whose community labels are likely to change on deletion/insertion of a few edges. However, our observations indicate that it suffers from identifying far too many vertices as affected --- requiring a large amount of work to identify the new communities.\ignore{Their algorithm also does not address the possibility of isolated community splits in the presence of intra-community edge deletions.}}

The \textit{$\Delta$-screening} technique laid out by Zarayeneh et al. \cite{com-zarayeneh21} has the properties of a desirable dynamic community detection algorithm. Despite this, our observations indicate that it suffers from identifying far too many vertices as affected --- requiring a large amount of work to identify the new communities. Their algorithm also does not address the possibility of isolated community splits in the presence of intra-community edge deletions.

In addition, the dynamic algorithms mentioned above are \textit{sequential} \cite{com-aynaud10, com-chong13, com-meng16, com-cordeiro16, com-zarayeneh21}. Thus, there is a need for efficient parallel algorithms for community detection on dynamic graphs.\ignore{We summarize the state-of-the-art in Table \ref{tab:comparision}.} Further, none of the works recommend reusing the previous \textit{total edge weight} of each vertex (which is required for local-moving phase of the Louvain algorithm) as auxiliary information to the dynamic algorithm. Recomputing it from scratch is expensive and becomes a bottleneck for dynamic Louvain algorithm.
\ignore{In addition, the dynamic algorithms mentioned above are \textit{sequential} \cite{com-aynaud10, com-chong13, com-meng16, com-cordeiro16, com-zarayeneh21}. Thus, there is a need for efficient parallel algorithms for community detection on dynamic graphs. Further, none of the works recommend reusing the previous \textit{total edge weight} of each vertex/community (required for local-moving phase of Louvain algorithm) as auxiliary information to the dynamic algorithm. Recomputing it from scratch is expensive and becomes a bottleneck for dynamic Louvain algorithm. We summarize the state-of-the-art in Table \ref{tab:comparision}.}

\ignore{Reidy and Bader \cite{com-riedy13} present a parallel dynamic algorithm for community detection. However, their work has a few limitations. They do not consider cascading changes to community labels on an update or study the modularity of obtained communities. They do not use \textit{Louvain} or \textit{LPA} in arriving at the communities and hence a direct comparison with their approach is not feasible.}

\ignore{propose an incremental algorithm built upon DEMON, an overlapping community detection method, while Nath and Roy \cite{nath2019detecting} present InDEN, another incremental algorithm. However, their algorithms do not handle edge deletions.}
